#!/usr/bin/env python3


from PyQt5 import QtWidgets
from PyQt5.QtWidgets import QMessageBox, QSystemTrayIcon
from PyQt5.QtGui import QIcon, QPixmap, QMovie
from PyQt5.QtCore import QTimer, QThread, pyqtSignal
from QLed import QLed
from design import Ui_MainWindow
from sys import exit
from requests import get
from selenium import webdriver
from selenium.webdriver.common.by import By
from shutil import copyfileobj
from urllib import request as url_request
from webbrowser import open as open_url
from os import path, system
from time import sleep, localtime, strftime
from threading import Thread
from json import dumps, load
from validators import url as check_url
from datetime import date
from alive_progress import alive_bar
from functools import partial
from xlwt import Workbook
from notifications import (checkURL, getDescription, loadImage, 
                           checkFixedOutput, parseRanobe, checkVoice)


dead = life = enable = checker_tag = True
down = while_var = tab_start = downloading = False
checklist = ()


def enableCheck(func):
    def wrapper(*flag):
        global enable, while_var, dead
        if enable:
            enable = False
            while_var = dead = True
            func(*flag)
            while_var = False
            enable = dead = True
    return wrapper


class ThreadProgress(QThread):
    _signal = pyqtSignal(int)
    def __init__(self, data, flag=True):
        super(ThreadProgress, self).__init__()
        self.flag = flag
        self.data = data
        self.current_path = path.dirname(path.realpath(__file__))
        self.check = 0


    def __del__(self):
        self.wait()


    def run(self):
        global dead, checker_tag, tab_start
        tab_start = 0
        checker_tag = False
        title = 'Checking ->' if self.flag else 'Updating ->'
        with alive_bar(len(self.data['anime']['urls']), title=title) as bar:
            for i in enumerate(self.data['anime']['urls']):
                try:
                    if dead == False: break 
                    series = self.data['anime']['series'][i[0]] + 1
                    ova = self.data['anime']['ova'][i[0]] + 1
                    name, check_output = checkURL(self.data, i[1], series, ova)
                    self.check += 1 if check_output else 0
                    if name == '':
                        raise Exception('ERROR FOR URL_CHECK..')
                    if self.flag == False:
                        if 'icons/' in self.data['anime']['images'][i[0]]:
                            img, desc = getDescription(i[1])
                            self.data['anime']['images'][i[0]] = f'description/{img}'
                            self.data['anime']['description'][i[0]] = desc
                        self.data['anime']['name'][i[0]] = name
                    index = i[0] + 1
                    percent = int(index / len(self.data['anime']['urls']) * 100)
                    self._signal.emit(percent)
                except Exception as e:
                    system(f'notify-send "Error checking anime\n{e}"')
                bar()
        self.data['notify']['notify'] = checkVoice(self.data, self.check)
        if isinstance(self.data, dict):
            with open(f'{self.current_path}/setting.json', 'w') as js:
                js.write(dumps(self.data, sort_keys=False, indent=4,
                               ensure_ascii=False, separators=(',', ': ')))
        sleep(1)
        percent = 0
        self._signal.emit(percent)
        del(self.check)
        checker_tag = True


class myWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super(myWindow, self).__init__()
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        self.current_path = path.dirname(path.realpath(__file__))
        self.setGeometry(*self.uploadGlobalSettings()['geometry'])

        self.flag = True
        self.click = self.percent = self.percent_all_anime = self.color = 0
        self.percent_all_manga = self.percent_desc_manga = self.ranobe_percent = 0
        self.ui.tabWidget.setCurrentIndex(0)
        self.path_down = f'{self.current_path}/downloads'
        self.option = webdriver.ChromeOptions()
        self.option.add_argument('--headless')
        self.icon = f'{self.current_path}/icons'
        self.movie = QMovie(f"{self.icon}/free.gif")

        self.sheme = (('dark', 'background: #313131', 'background: #888888'),
                      ('lamp', 'background: #FFFFFF', 'background: #FFFFFF'))
        self.up = (self.ui.toolButton_20, self.ui.toolButton_17,
                   self.ui.toolButton_26, self.ui.toolButton_31)
        self.comboboxes = (self.ui.comboBox, self.ui.comboBox_2,
                           self.ui.comboBox_6, self.ui.comboBox_7)
        self.dict_funcs = {0: self.wrapperData, 1: self.wrapperEnable,
                           2: self.wrapperCheckbox, 4: self.wrapperUpdate,
                           8: lambda e: self.ui.progressBar.setValue(e),
                           9: lambda e: self.ui.progressBar_3.setValue(e),
                           10: lambda e: self.ui.progressBar_7.setValue(e)}
        bar = (self.ui.progressBar.setStyleSheet,self.ui.progressBar_2.setStyleSheet,
              self.ui.progressBar_3.setStyleSheet,self.ui.progressBar_7.setStyleSheet)
        labels_movie = (self.ui.label_2, self.ui.label_3, self.ui.label_8,
                        self.ui.label_9, self.ui.label_10, self.ui.label_11)
        gen = (self.ui.toolButton_2, self.ui.toolButton_19, self.ui.toolButton_29,
               self.ui.toolButton_8, self.ui.toolButton_13, self.ui.toolButton_27,
               self.ui.toolButton_21, self.ui.toolButton_30, self.ui.toolButton,
               self.ui.toolButton_15, self.ui.toolButton_32, self.ui.toolButton_12)
        new_box = (*self.comboboxes[:-1:],self.ui.comboBox_3,self.ui.comboBox_4)
        tuple_none = (self.ui.toolButton_24,self.ui.toolButton_10,
                      self.ui.toolButton_11,self.ui.toolButton_25)
        buts =(self.ui.pushButton,self.ui.toolButton_3,self.ui.toolButton_5,
               self.ui.toolButton_6,self.ui.toolButton_10,self.ui.toolButton_11,
               self.ui.toolButton_14,self.ui.toolButton_18,self.ui.toolButton_24)
        funcs = (self.startExport,self.closed,self.oneDown,self.stoped,
                 self.notifyCheck,self.modeColorSheme,self.openPlayer,
                 self.openURL,self.aboutInfo)
        colors = ('#00e916', '#8BC6EC;', '#FFE53B;', '#FF3CAC;')
        func_time = (self.everySecond, self.tracker)

        self.ui.dockWidget.hide()
        self.ui.dockWidget.setGeometry(555,75, 164,80)

        self.timer = [QTimer() for _ in range(2)]
        [self.timer[i].timeout.connect(v) for i,v in enumerate(func_time)]
        [self.timer[i].start(v) for i,v in enumerate((1000, 420_000))]
        self.tracker()
        
        self.tray = QSystemTrayIcon(self)
        self.tray.activated.connect(self.triggerFocus)
        self.tray.show()

        self.led = QLed(self, onColour=QLed.Green, shape=QLed.Circle)
        self.led.setGeometry(370, 135, 12, 12)

        self.defaultIcon()
        self.checkModeSheme()

        [i.setMovie(self.movie) for i in labels_movie]
        [self.showed(*i) for i in enumerate(self.comboboxes)]
        [i.setStyleSheet('border: none;') for i in tuple_none]
        [bar[i](f'selection-background-color: {v}') for i,v in enumerate(colors)]
        [(self.changed(i), v.activated.connect(partial(self.changed, i)))
            for i,v in enumerate(new_box)]
        
        [v.clicked.connect(funcs[i]) for i,v in enumerate(buts)]
        for i in enumerate(gen):
            match i[0]:
                case 0 | 1 | 2:  i[1].clicked.connect(self.deleted)
                case 3 | 4 | 5:  i[1].clicked.connect(self.loged)
                case 6 | 7:      i[1].clicked.connect(self.edited)
                case 8 | 9 | 10: i[1].clicked.connect(self.saved)
                case _:          i[1].clicked.connect(self.checkItems)
        [j.clicked.connect(partial(self.checkingItems, (True if i % 2 == 1 
            else False, i))) for i,j in enumerate(self.up)]
        

#### <<< Main-module >>> ####
    def keyPressEvent(self, QKeyEvent):
        int_key = QKeyEvent.key()
        if int_key == 16777216:
            self.hidded()


    def uploadGlobalSettings(self):
        try:
            with open(f'{self.current_path}/setting.json', 'r') as reads:
                data = load(reads)
        except:
            data = self.uploadGlobalSettings()
        return data


    def setGlobalSettings(self, to_json, tab, mode, var, flag=False, state=False):
        if state == False:
            if flag:
                to_json[mode].append(var) if tab == "" else \
                    to_json[tab][mode].append(var)
            else:
                if tab == '':
                    to_json[mode] = var
                else:
                    to_json[tab][mode] = var
        if isinstance(to_json, dict):
            with open(f'{self.current_path}/setting.json', 'w') as js:
                js.write(dumps(to_json, sort_keys=False, indent=4,
                        ensure_ascii=False, separators=(',', ': ')))
        else:
            system(f'notify-send "Error, no update file <setting.json>"')


    def startExport(self):
        mode = self.ui.comboBox_5.currentText()
        format = self.ui.comboBox_8.currentText()
        data = self.uploadGlobalSettings()['history']
        saved = f'{self.current_path}/history.{format}'
        if len(data[mode]) > 0:
            if format in ('md', 'txt'):
                with open(saved, 'w') as f:
                    [f.write(f'{i}\n') for i in data[mode]]
            elif format == 'json':
                with open(saved, 'w') as f:
                    f.write(dumps(data[mode], sort_keys=False, indent=4,
                                   ensure_ascii=False, separators=(',', ': ')))
            elif format == 'xlsx':
                writing_book = Workbook()
                writing = writing_book.add_sheet(f'export history {mode}')
                [writing.write(i[0],0,i[1]) for i in enumerate(data[mode])]
                writing_book.save(saved)
        self.ui.dockWidget.close()


    def stoped(self):
        global while_var
        if while_var:
            rezult = self.message('Do you really want to finished process?',
                                  (541, 107, 200, 200), True, True)
            if rezult == QMessageBox.Ok:
                self.extraClose()
        else:
            self.message('No active processes for ending!',(541, 107, 200, 200))


    def hidded(self):
        self.hide()
        self.click += 1


    def extraClose(self):
        global dead, life
        dead = life = False
        system('killall -s 9 chromedriver')
        self.defaultIcon()


    def closed(self):
        rezult = self.message('Do you really want to leave?',
                              (541, 107, 200, 200), True, True)
        (self.extraClose(),self.close()) if rezult == QMessageBox.Ok else None


    def aboutInfo(self):
        self.message(self.uploadGlobalSettings()['about'],(600, 75, 300, 100))


#<<<<!>>>> Function worker every second
    def variableTime(self):
        global checker_tag, enable, tab_start, down, while_var 
        data = self.uploadGlobalSettings()['notify']['notify']
        index = self.ui.tabWidget.currentIndex()
        updates = False if self.ui.checkBox_3.isChecked() else True
        checkbox = True if self.ui.checkBox_2.isChecked() else False   
        self.flag = False if while_var else True
        
        return (data, enable, checkbox, checker_tag,
                index, tab_start, self.percent_all_anime,
                self.percent, self.percent_all_manga, self.ranobe_percent,
                while_var, down, updates)


    def everySecond(self):
        self.timeNumber(*self.variableTime())


    def timeNumber(self, data, enable, checkbox, tag, index, tabs,
                   anime, percent, manga, ranobe_percent, var, down, up):
        global checklist
        
        gets = (data, enable, checkbox, tag, up, index, tabs,
                  anime, percent, manga, ranobe_percent, var, down)
        indexs = [i for i in range(len(gets)) if len(checklist) == 0 \
                                              or checklist[i] != gets[i]]
        if len(indexs) > 0:
            for i in indexs:
                self.iconTab(*gets[5:7:], *gets[-2::]) if i in (5,6,11,12) else \
                self.wrapperCheckerTag(gets[3], gets[7]) if i in (3,7) else \
                self.dict_funcs[i](gets[i])
            checklist = gets


    def iconTab(self, index, tab, while_var=False, down=False):
        self.ui.toolButton_24.setToolTip('About')
        pre = 'AnimeVost tracker' if index == 0 else 'Manga tracker' if index == 1 \
              else 'Ranobe tracker' if index == 2 else 'View descriptions'
        if self.flag:
            ico = 'animevost.png' if index == 0 else 'mask.png' if index == 1 \
                else 'ranobe.png' if index == 2 else 'a-desc.png'
        else:
            ico = 'dow.png' if while_var and down and tab == 0 else \
                  'animevost-new.webp' if tab == 0 else 'mask-0.png' \
                                       if tab == 1 else 'ranobe-0.png'
        tool = 'Download file..' if down else pre
        self.tray.setToolTip(tool)
        self.tray.setIcon(QIcon(f'{self.icon}/{ico}'))
            

    def wrapperData(self, data):
        ico = 'notification' if data == 'checked' else 'notify' \
                             if data == 'unchecked' else 'bell'
        self.ui.toolButton_10.setIcon(QIcon(f'{self.icon}/{ico}.png'))


    def wrapperEnable(self, enable):
        self.movie.stop() if enable else self.movie.start()
        self.led.value = False if enable else True
        self.led.setToolTip('Not Working..' if enable else 'Working..')
        self.visibled() if enable else None


    def wrapperCheckbox(self, checkbox):
        ico = 'all-click' if checkbox else 'click'
        tool = 'Download All Elements' if checkbox else 'Download Current Element'
        self.ui.toolButton_5.setIcon(QIcon(f'{self.icon}/{ico}.png'))
        self.ui.toolButton_5.setToolTip(tool)
    

    def wrapperCheckerTag(self, check, anime_percent):
        self.percent_all_anime = anime_percent if check else 0
        self.ui.progressBar_2.setValue(anime_percent) if check else False
    

    def wrapperUpdate(self, checkbox):
        ico = 'checking' if checkbox else 'circle'
        tool = 'Tracking Elements' if checkbox else 'Update Elements'
        self.ui.toolButton_12.setIcon(QIcon(f'{self.icon}/{ico}.png'))
        self.ui.toolButton_12.setToolTip(tool)
#<<<<!>>>>


    def editLineEdit(self, edit):
        sleep(2.5)
        edit.setText('')
        data = self.uploadGlobalSettings()['mode']
        edit.setStyleSheet('background: rgb(136, 136, 136)' if data == 'darkmode' 
            else 'background: rgb(220, 220, 220)')


    def notifyCheck(self):
        data = self.uploadGlobalSettings()
        data['notify']['notify'] = 'empty' if self.emptyNotify(data) else 'checked'
        title = ('No notification..',(600, 95, 300, 100)) if self.emptyNotify(data) \
            else ("\n".join([''.join(data['notify'][i]) for i in data['notify']
            if i not in 'notify']),(420, 95, 300, 100))
        self.setGlobalSettings(data, '', '', '', False, True)
        self.message(*title)


    def modeColorSheme(self):
        mode = 'darkmode' if self.color % 2 == 0 else 'lightmode'
        self.changeSheme(*self.sheme[0 if self.color % 2 == 0 else 1])
        self.setGlobalSettings(self.uploadGlobalSettings(), '', 'mode', mode)
        self.color += 1


    def checkModeSheme(self):
        reads = self.uploadGlobalSettings()
        self.color = 0 if reads['mode'] == 'lightmode' else 1
        self.changeSheme(*self.sheme[0 if self.color % 2 == 1 else 1])


    def changeSheme(self, ico, win, back):
        self.setStyleSheet(win)
        list_back = (self.ui.lineEdit, self.ui.lineEdit_2, self.ui.lineEdit_3,
            self.ui.textEdit, *self.comboboxes, self.ui.comboBox_3,
            self.ui.comboBox_4, self.ui.comboBox_5, self.ui.comboBox_8,
            self.ui.spinBox, self.ui.doubleSpinBox, self.ui.doubleSpinBox_2,
            self.ui.lcdNumber, self.ui.lcdNumber_2, self.ui.lcdNumber_3,
            self.ui.lcdNumber_4, self.ui.lcdNumber_5, self.ui.lcdNumber_6,
            self.ui.toolButton_11, self.ui.toolButton_24, self.ui.pushButton,
            self.ui.pushButton_2)
        ls = (QIcon(f'{self.icon}/{ico}.png'), QIcon(f'{self.icon}/{ico}-about.png'))
        lcheck = (self.ui.checkBox,self.ui.checkBox_2,
                  self.ui.checkBox_3,self.ui.checkBox_4)
        [v.setStyleSheet(back) for i,v in enumerate(list_back) if i not in (21,22)]
        [v.setIcon(ls[i]) for i,v in enumerate(list_back[21:23:])]

        tool = {'lamp':('Lightmode', '#0b76ef'), 'dark':('Darkmode', '#8B33B5')}
        list_back[21].setToolTip(tool[ico][0])
        [i.setStyleSheet(f'background-color:{tool[ico][1]};') for i in lcheck]


    def defaultIcon(self, value = 5):
        list_tab = ('animevost.png', 'mask.png', 'ranobe.png', 'a-desc.png')
        for i in enumerate(list_tab):
            self.ui.tabWidget.setTabIcon(i[0], QIcon(f'{self.icon}/{i[1]}'))
            if i[0] < 3:
                self.ui.comboBox_4.setItemIcon(i[0], QIcon(f'{self.icon}/{i[1]}'))
        list_tool = (
            self.ui.toolButton_2, self.ui.toolButton_19, self.ui.toolButton_29,
            self.ui.toolButton_26, self.ui.toolButton_20, self.ui.toolButton_8,
            self.ui.toolButton_27, self.ui.toolButton_13,self.ui.toolButton,
            self.ui.toolButton_15, self.ui.toolButton_32, self.ui.toolButton_17,
            self.ui.toolButton_31, self.ui.toolButton_21, self.ui.toolButton_30,
            self.ui.toolButton_7, self.ui.toolButton_4, self.ui.toolButton_18,
            self.ui.toolButton_3, self.ui.toolButton_6, self.ui.toolButton_14,
            self.ui.toolButton_16, self.ui.toolButton_25
        )
        lists = ('trash', 'circle', 'log-one', 'diskette', 'checking', 'edit',
                 'checkbox-1', 'checkbox-2', 'web', 'close', 'lose', 'player',
                 'checkbox-3', 'history')
        list_icon = [QIcon(f'{self.current_path}/icons/{i}.png') for i in lists]
        list_tool[18].setToolTip('Exit')
        for i in enumerate(list_tool):
            match i[0]:
                case 0 | 1 | 2:  value = 0
                case 3 | 4:      value = 1
                case 5 | 6 | 7:  value = 2
                case 8 | 9 | 10: value = 3
                case 11 | 12:    value = 4
                case 13| 14:     value = 5
                case _:          value += 1
            i[1].setIcon(list_icon[value])


    def triggerFocus(self, reason):
        if (reason == QSystemTrayIcon.Trigger or
            reason == QSystemTrayIcon.MiddleClick):
            self.show() if self.click % 2 == 0 else self.hide()
            self.click += 1


    def openPlayer(self):
        index = self.ui.lcdNumber.intValue() if self.ui.spinBox.value() == 0 else \
                self.ui.spinBox.value()
        name = "_".join(self.ui.comboBox.currentText().split())
        if index > 0 and index <= self.ui.lcdNumber.intValue():
            link = f"{self.path_down}/{name}/{name}-{index} серия.mp4"
            Thread(target = system, args = (f'mpv "{link}"',)).start()
        else:
            self.message('No file..', (514, 107, 200, 200))


    def openURL(self):
        tab = self.ui.tabWidget.currentIndex()
        data = self.uploadGlobalSettings()
        child = 'track-link' if tab == 0 and self.ui.checkBox.isChecked() else \
                'urls'
        index = self.comboboxes[-1].currentIndex() if tab == 0 and \
                self.ui.checkBox.isChecked() else self.comboboxes[tab].currentIndex()
        mode = 'anime' if tab == 0 else 'manga' if tab == 1 else 'ranobe'
        open_url(data[mode][child][index]) if len(data[mode][child]) > 0 else \
            system(f'notify-send "List <{mode}> is empty"')


    @enableCheck
    def deleted(self, flag=None):
        data = self.uploadGlobalSettings()
        tab = self.ui.tabWidget.currentIndex()
        catch = 'log' if tab in (0,2) else 'logs'
        throw = 'names' if tab in (1,2) else 'name'
        mode = 'anime' if tab == 0 else 'manga' if tab == 1 else 'ranobe'
        ico = 'animevost' if tab == 0 else 'mask' if tab == 1 else 'ranobe'
        index = self.comboboxes[tab].currentIndex()
        icon = f'icons/{ico}.png'
        rezult = self.message('Are you sure you want to delete this entry?',
                              (514, 107, 200, 200), True, True)
        if rezult == QMessageBox.Ok:
            save_to_history = self.message('Save to history?',
                                           (544, 107, 200, 200), True, True)
            dirs = "_".join(data[mode][throw][index].split())
            if save_to_history == QMessageBox.Ok:
                data['history'][mode].append(data[mode][throw][index])
                move = f'mv "{self.path_down}/{dirs}" "{self.path_down}/history/"'
            rem = f'rm -r "{self.path_down}/{dirs}"'
            system(move if save_to_history == QMessageBox.Ok else rem) 
            remove = f'rm {self.current_path}/{data[mode]["images"][index]}'
            system(remove) if  data[mode]["images"][index] != icon else True
            self.checkNotify(data, mode, data[mode][throw][index])
            [data[mode][i].pop(index) for i in data[mode] if i not in catch]
            self.setGlobalSettings(data, '', '', '', False, True)
            if self.ui.comboBox_4.currentIndex() == tab:
                self.ui.comboBox_3.clear()
                self.ui.comboBox_4.setCurrentIndex(tab)
            self.showed(tab, self.comboboxes[tab])


    def loged(self):
        tab = self.ui.tabWidget.currentIndex()
        data = self.uploadGlobalSettings()
        log = 'logs' if tab == 1 else 'log'
        mode = 'anime' if tab == 0 else 'manga' if tab == 1 else 'ranobe'
        txt = '\n'.join(data[mode][log]) if log == 'logs' and data[mode][log] \
              else data[mode][log] if data[mode][log] else 'No file exist...'
        self.message(txt, (420, 95, 300, 100))


    def edited(self):
        tab = self.ui.tabWidget.currentIndex()
        data = self.uploadGlobalSettings()
        child = ('manga','numbers') if tab == 1 else ('ranobe','chapters')
        index = self.ui.comboBox_2.currentIndex() if tab == 1 else \
                self.ui.comboBox_6.currentIndex()
        text = self.ui.comboBox_2.currentText() if tab == 1 else \
                self.ui.comboBox_6.currentText()
        value = self.ui.doubleSpinBox.value() if tab == 1 else \
                self.ui.doubleSpinBox_2.value()
        if value != 0.0:
            decimal = int(str(value).split('.')[1])
            value = int(value) if decimal == 0 else float(value)
            data[child[0]][child[1]][index] = value
            self.checkNotify(data, child[0], text, value)
            data['notify']['notify'] = 'empty' if self.emptyNotify(data) else \
                                       data['notify']['notify']
            self.setGlobalSettings(data, '', '', '', False, True)
            self.ui.doubleSpinBox.setValue(0) if child[0] == 'manga' else \
            self.ui.doubleSpinBox_2.setValue(0)
            self.changed(tab)


    def checkNotify(self, data, ch, text, value = None, check = True):
        char = 'chapter' if check else 'series'
        tmp = f'{text} - new ' if value is None else \
              f'{text} - new {char} {value}'
        temp = f'{text} - new ova' if ch in 'anime' else 'NOT CHECK'
        while True:
            for i in range(len(data['notify'][ch])):
                if tmp in data['notify'][ch][i] or temp in data['notify'][ch][i]:
                    del(data['notify'][ch][i])
                    break
            else:
                break


    def emptyNotify(self, data):
        note = [len(data['notify'][i]) for i in data['notify'] if i != 'notify']
        return True if sum(note) == 0 else False


    @enableCheck
    def saved(self, flag=None):
        tab = self.ui.tabWidget.currentIndex()
        data = self.uploadGlobalSettings()
        name = 'names' if tab in (1,2) else 'name'
        mode = 'anime' if tab == 0 else 'manga' if tab == 1 else 'ranobe'
        mask = 'animevost' if tab == 0 else 'mask' if tab == 1 else 'ranobe'
        icon = QIcon(f'{self.icon}/{mask}.png')
        catch = ('log', 'track-name', 'track-link') if tab == 0 else \
                 'logs' if tab == 1 else 'log'
        series = self.ui.spinBox.value() if tab == 0 else \
                 self.ui.doubleSpinBox.value() if tab == 1 else \
                 self.ui.doubleSpinBox_2.value()
        edit = (self.ui.lineEdit, self.ui.lineEdit_2, self.ui.lineEdit_3)
        track = self.ui.comboBox_7.currentIndex()
        url = data['anime']['track-link'][track] if tab == 0 \
                  and self.ui.checkBox.isChecked() else edit[tab].text()
        title = self.ui.comboBox_7.currentText().split(' / ')[0] if tab == 0 \
                  and self.ui.checkBox.isChecked() else ''
        ico = f'icons/{mask}.png'
        dicts = {0: url, 1: series, 2: 0, 3: title, 5: '', 6: ico} if tab == 0 \
                else {0: url, 1: series, 2: 0, 3: '', 6: '', 5: ico} if tab == 1 \
                else {0: url, 2: series, 3: 0, 4: 0, 1: title, 5: '', 6: ico}
        if check_url(url):
            edit[tab].setStyleSheet('background: rgb(98, 255, 59)')
            [data[mode][i[1]].append(dicts[i[0]]) for i in enumerate(data[mode])
                if i[1] not in catch]
            self.comboboxes[tab].addItem(title)
            self.comboboxes[tab].setItemIcon(len(data[mode][name])-1, icon)
            self.setGlobalSettings(data, '', '', '', False, True)
        else:
            system(f'notify-send "Error add {mode}"')
            edit[tab].setStyleSheet('background: rgb(236, 0, 0)')
            edit[tab].setText('  ERROR check URL..')
        Thread(target = self.editLineEdit, args = (edit[tab],)).start()


    def showed(self, index, combo):
        name = 'name' if index == 0 else 'names' if index in (1,2) else 'track-name'
        child = 'anime' if index in (0,3) else 'manga' if index == 1 else 'ranobe'
        ico = 'animevost' if index in (0,3) else 'mask' if index == 1 else 'ranobe'
        combo.clear()
        data = self.uploadGlobalSettings()[child][name]
        for i in enumerate(data):
            combo.addItem(i[1])
            combo.setItemIcon(i[0], QIcon(f'{self.icon}/{ico}.png'))


    def changed(self, tab, stop = False):
        data = self.uploadGlobalSettings()
        mode = 'anime' if tab == 0 else 'manga' if tab == 1 else \
               'ranobe' if tab == 2 else self.ui.comboBox_4.currentText()
        name = 'name' if  mode in 'anime' else 'names'
        child = 'series' if tab == 0 else 'numbers' if tab == 1 \
                                     else 'chapters' if tab == 2 else name
        stop = False if len(data[mode][child]) == 0 else True
        twin = 'change_numbers' if mode in 'manga' else 'access-chapters' \
                if mode in 'ranobe' else 'series'
        index = self.comboboxes[tab].currentIndex() if tab in (0,1,2) else \
                self.ui.comboBox_3.currentIndex() if tab == 3 else \
                self.ui.comboBox_4.currentIndex()
        lcd = (self.ui.lcdNumber, self.ui.lcdNumber_2, self.ui.lcdNumber_3,
               self.ui.lcdNumber_4, self.ui.lcdNumber_5, self.ui.lcdNumber_6)
        lcd_check = lcd[:1:] if tab == 0 else lcd[1:3:] if tab == 1 else \
                    lcd[3::] if tab == 2 else None if tab == 3 else False
        if stop == False and tab == 4:
            self.ui.comboBox_3.clear()
            self.ui.label_5.setPixmap(QPixmap())
        elif stop:
            num = float(
                f"{data['anime']['series'][index]}.{data['anime']['ova'][index]}"
                    if tab == 0 else 0)
            current = data[mode][child][index] if tab in (1,2) else num
            but = self.ui.toolButton_21 if tab == 1 else self.ui.toolButton_30
            if lcd_check is None:
                self.ui.label_5.setPixmap(QPixmap(
                    f'{self.current_path}/{data[mode]["images"][index]}'))
                self.ui.textEdit.setHtml(data[mode]['description'][index])
            elif lcd_check == False:
                self.ui.comboBox_3.clear()
                ico = 'animevost' if index == 0 else 'mask' if index == 1 else 'ranobe'
                for i in enumerate(data[mode][name]):
                    self.ui.comboBox_3.addItem(i[1])
                    self.ui.comboBox_3.setItemIcon(i[0], QIcon(f'{self.icon}/{ico}.png'))
                self.changed(3)
            else:
                for i,v in enumerate(lcd_check):
                    v.display(current if i == 0 else data[mode][twin][index] \
                          if i == 1 else data[mode]['future-chapters'][index])
                back = ('rgb(50, 233, 37)', False) if data[mode][child][index] == \
                       data[mode][twin][index] else ('rgb(192, 16, 16)', True)
                [i.setStyleSheet(f'background: {back[0]}') for i in lcd_check \
                    if i != lcd_check[0]]
                tup = (1,2) if tab == 1 else (3,4) if tab == 2 else False
                False if tup == False else but.setEnabled(True) if \
                    lcd[tup[0]].value() < lcd[tup[1]].value() else but.setEnabled(False)


    def visibled(self):
        [i.show() for i in (self.ui.toolButton_5, self.ui.toolButton_12, *self.up)]


    def checkingItems(self, tup):
        data = self.uploadGlobalSettings()
        self.up[tup[1]].hide()
        func = self.upUrls if tup[1] in (0,1) else self.setRanobe
        args = (data, not tup[0]) if tup[1] in (0,1) else (tup[0], data)
        Thread(target = func, args = args).start()


    def message(self, txt, geo, ico = False, but = False):
        al = QMessageBox()
        al.setIcon(QMessageBox.Information) if ico else None
        al.setText(txt)
        al.setGeometry(*geo)
        al.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel) if but else None
        return al.exec()


####<<< Anime-module >>>####
    @enableCheck
    def oneParsing(self, data, url, digit):
        global dead, tab_start
        tab_start = 0
        driver = webdriver.Chrome(path.join(path.dirname(__file__), 'chromedriver'),
                                  options=self.option)
        urls = data['anime']['urls']
        try:
            self.percent_all_anime = 5
            driver.get(url)
            self.percent_all_anime = 15
            sleep(3)
            search_count_series = driver.find_elements(By.CLASS_NAME, 'epizode')
            name = driver.find_element(By.CLASS_NAME, 'shortstoryHead').text
            next = driver.find_element(By.CLASS_NAME, 'next')
            name_dir = name.split(' /')
            self.percent_all_anime = 35
            log = ''
            series = digit + 1 + data['anime']['ova'][urls.index(url)]

            def continueDownload(count = 0, repeat = False):
                nonlocal search_count_series, series, name, \
                          next, name_dir, data, log
                count = series
                while count > 0:
                    if series <= 6: break
                    next.click()
                    count -= 6

                self.percent_all_anime = 40
                step = -1 if count == 0 else series - 1
                if data['anime']['ova'][urls.index(url)] > 0:
                    step = -(data['anime']['ova'][urls.index(url)]+1)
                while True:
                    click_i = search_count_series[step].text
                    if click_i != '': break
                search_count_series[step].click()
                sleep(15)

                iframe = driver.find_elements(By.TAG_NAME, 'iframe')
                for item in range(len(iframe)):
                    driver.switch_to.frame(iframe[item])
                    down = driver.find_elements(By.CLASS_NAME, 'butt')
                    if len(down) == 4: break
                    driver.switch_to.default_content()
                down = down[3 if self.ui.checkBox_4.isChecked() else 2]
                let = down.get_attribute("href").split('?')[0].split('/')
                self.percent_all_anime = 65
                self.Download(down.get_attribute('href'), let[-1], urls,
                              name_dir[0], url, name, series, data, click_i)
                self.percent_all_anime = 97
                log = f'{name_dir[0]} - New series {series}'
                driver.switch_to.default_content()
                if repeat:
                    series += 1
                    fl = True if len(search_count_series) - series > 0 else False
                    continueDownload(len(search_count_series) - series, fl)

            length = len(search_count_series)
            continueDownload(length - series, True) if length > series else \
            continueDownload()
        except Exception as e:
            system(f'notify-send "Error one-down\n<< {e} >>"')
            log = f"!!! << Error: {e} >> !!!"

        driver.quit()
        data['anime']['log'] = log
        self.setGlobalSettings(data, 'anime', 'log', log)
        self.percent_all_anime = 100
        self.ui.progressBar_2.setFormat('Completed')
        sleep(1.2)
        self.percent_all_anime = 0
        self.ui.progressBar_2.setFormat('%p%')


    def checkUpload(self, f, url, dirs, link, name, series, data, search='серия'):
        curent_time = strftime("%H:%M", localtime())
        names_dir = '_'.join(dirs.split())
        child = 'series' if 'серия' in search else 'ova'
        data['anime'][child][url.index(link)] += 1
        ova = data['anime']['ova'][url.index(link)] if 'ОВА' in search else False
        series = f"ova-{ova}" if 'ОВА' in search else f'{series} серия'
        system(f'notify-send "Вышла {series}! {name}\n{curent_time}"')
        False if path.isdir(f'{self.path_down}') else \
            system(f'mkdir "{self.path_down}"') 
        if not path.isdir(f'{self.path_down}/{names_dir}'):
            system(f'mkdir "{self.path_down}/{names_dir}"')
        system(f'mv "{self.path_down}/_{f}" \
                    "{self.path_down}/{names_dir}/{names_dir}-{series}.mp4"')
        self.setGlobalSettings(data, 'anime', 'series', data['anime']['series'])


    def handleProgress(self, blocknum, blocksize, totalsize):
        global dead, down
        readed_data = blocknum * blocksize
        if totalsize > 0:
            down = True
            self.percent = int(readed_data * 100 / totalsize)
            if dead == False:
                raise Exception("Sorry, no numbers below zero")
            QtWidgets.QApplication.processEvents()


    def Download(self, dow, f, urls, dirs, link, name, serie, data, sea):
        global dead, down, downloading
        save_loc = f'{self.current_path}/downloads/_{f}'
        txt = f'Download:\n{dirs} -> {data["anime"]["series"][urls.index(link)]+1}'
        try:
            self.ui.progressBar.setToolTip(txt)
            self.ui.progressBar.setFormat('Complete %p%')
            url_request.urlretrieve(dow, save_loc, self.handleProgress)
            downloading = True
            self.ui.progressBar.setFormat('Completed')
            self.checkNotify(data, 'anime', dirs, serie, False)
            data['notify']['notify'] = 'empty' if self.emptyNotify(data) else \
                                       data['notify']['notify']
            self.checkUpload(f, urls, dirs, link, name, serie, data, sea)
        except Exception as e:
            downloading = False
            system(f'rm {self.current_path}/downloads/_{f}')
            system(f'notify-send "Error download anime: {dirs}\n{e}"')
            print('Error: ==>\n', e)
            self.ui.progressBar.setToolTip(f'Error {txt}')
        down = False


    def progressCount(self, percent):
        self.ui.progressBar_2.setValue(percent)


    def tracker(self):
        Thread(target = self.uploadTrackerAnime).start()


    @enableCheck
    def uploadTrackerAnime(self):
        global tab_start
        tab_start = 0
        data = self.uploadGlobalSettings()
        try:
            names, links = checkFixedOutput(data, 0)
            self.setGlobalSettings(data, 'anime', 'track-name', names)
            self.setGlobalSettings(data, 'anime', 'track-link', links)
        except Exception as e:
            system(f'notify-send "Error for update Checker Anime:\n{e}"')
        self.showed(3, self.ui.comboBox_7)


    def checkItems(self, flags = False):
        data = self.uploadGlobalSettings()
        self.ui.toolButton_12.hide()
        flag = True if flags else False if self.ui.checkBox_3.isChecked() else True
        Thread(target = self.clicker, args = (data, not flag)).start()


    @enableCheck
    def clicker(self, data, check=True):
        self.thread_class = ThreadProgress(data, not check)
        self.thread_class._signal.connect(self.progressCount)
        self.thread_class.start()
        self.thread_class.wait()


    def oneDown(self):
        data = self.uploadGlobalSettings()
        self.ui.toolButton_5.hide()
        el = [i.split(' > ')[1].split(' - new')[0] for i in data['notify']['anime']]
        seti = list(set([data['anime']['name'].index(i) for i in el]))
        value = self.ui.lcdNumber.intValue()
        index = self.ui.comboBox.currentIndex()
        args = (data, seti) if self.ui.checkBox_2.isChecked() else \
               (data, data['anime']['urls'][index], value)
        func = self.checkDelOrDown if len(args) < 3 else self.oneParsing
        thread = Thread(target = func, args = args)
        thread.start() if index in seti and len(args) > 2 or \
                          len(seti) > 0 and len(args) < 3 else \
            (self.message('No data for update..', (560, 75, 100, 100),
                          True, False), self.visibled())


    def checkDelOrDown(self, data, seti):
        global life, downloading
        life = True
        while len(seti) > 0:
            url = data['anime']['urls'][seti[0]]
            series = data['anime']['series'][seti[0]]
            self.oneParsing(data, url, series)
            seti.remove(seti[0]) if downloading else False
            seti = seti if life else []
        life = True


####<<< Manga-module >>>####
    @enableCheck
    def upUrls(self, data, update_check = False):
        global dead, tab_start
        tab_start = 1
        msg = []
        length = len(data['manga']['urls'])
        title = 'Update ' if update_check else 'Check '
        driver = webdriver.Chrome(path.join(path.dirname(__file__), 'chromedriver'),
                                  options=self.option)
        for i in enumerate(data['manga']['urls']):
            try:
                with alive_bar(5, title = f'{title}{i[0]} -> ') as bar:
                    bar()
                    if dead == False: break
                    ii = i[0] + 1
                    self.percent_all_manga = int(ii / length * 100)
                    driver.get(i[1])
                    sleep(2)
                    bar()
                    if 'https://manga-chan.me' in i[1]:
                        manga = driver.find_elements(By.CLASS_NAME,
                            'manga2')[0].text.split(' Глава ')[1].split(' ')[0]
                        if '.' in manga:
                            manga = float(manga)
                        else:
                            manga = int(manga)
                        name = driver.find_element(By.CLASS_NAME,
                            'title_top_a').text.split('(')[-1][:-1:]
                        img = driver.find_element(By.ID, 'cover').get_attribute('src')
                        desc = driver.find_element(By.ID, 'description').text
                    else:
                        manga = driver.find_element(By.CLASS_NAME,
                                    'mt-3').text.split(' ')
                        if manga[-1].isdigit():
                            manga = int(manga[-1])
                        elif manga[-2].isdigit():
                            manga = int(manga[-2])
                        else:
                            try:
                                manga = float(manga[-1])
                            except:
                                manga = float(manga[-2])
                        name = driver.find_element(By.CLASS_NAME, 'name').text
                        img = driver.find_elements(By.CLASS_NAME,
                            'fotorama__img')[0].get_attribute('src')
                        desc = driver.find_element(By.CLASS_NAME,
                            'manga-description').text
                    bar()
                    data['manga']['change_numbers'][i[0]] = manga
                    log = f'{name} = {manga}'
                    if data['manga']['numbers'][i[0]] < manga:
                        c_d = date.today()
                        c_t = strftime("%H:%M", localtime())
                        log = f'{name} → {manga}'
                        head = f'[M][{c_d.day}/{c_d.month}/{c_d.year} - {c_t}] > '
                        body = f'{head} {name} - new chapter {manga}\n'
                        msg.append(body)
                    data['manga']['logs'][i[0]] = log
                    bar()
                    if update_check:
                        if 'description/' not in data['manga']['images'][i[0]]:
                            image = img.split('/')[-1]
                            r = get(img, stream=True)
                            if r.status_code == 200:
                                with open(f'{self.current_path}/description/{image}',
                                    'wb') as f:
                                    r.raw.decode_content = True
                                    copyfileobj(r.raw, f)
                            loadImage(image)
                            data['manga']['images'][i[0]] = f'description/{image}'
                            data['manga']['description'][i[0]] = desc
                        data['manga']['names'][i[0]] = name
                    bar()
            except Exception as e:
                system(f'notify-send "Error check manga\n{e}"')
        driver.quit()
        data['notify']['manga'] += msg if len(msg) > 0 else []
        data['notify']['notify'] = checkVoice(data, len(msg))
        self.setGlobalSettings(data, '', '', '', False, True)
        sleep(0.8)
        self.percent_all_manga = 0


#### <<< Tab Ranobe >>> ####
    @enableCheck
    def setRanobe(self, check, data):
        global tab_start, dead
        tab_start = 2
        msg = self.ranobe_percent = 0
        length = len(data['ranobe']['urls'])
        for i in enumerate(data['ranobe']['urls']):
            try:
                if dead == False: break
                name, img, description, chapter, all = parseRanobe(i[1])
                image = img.split('/')[-1]
                if data['ranobe']['chapters'][i[0]] < float(chapter):
                    c_d = date.today()
                    c_t = strftime("%H:%M", localtime())
                    msg += 1
                    head = f'[R][{c_d.day}/{c_d.month}/{c_d.year} - {c_t}]'
                    body = f'> {name} - new chapter {chapter}\n'
                    note = f'{head} {body}'
                    data['notify']['ranobe'].append(note)
                if check == False:
                    r = get(img, stream=True)
                    if r.status_code == 200:
                        with open(f'{self.current_path}/description/{image}',
                            'wb') as f:
                            r.raw.decode_content = True
                            copyfileobj(r.raw, f)
                        loadImage(image)
                    data['ranobe']['images'][i[0]] = f'description/{image}'
                    data['ranobe']['names'][i[0]] = name
                    data['ranobe']['description'][i[0]] = description
                data['ranobe']['access-chapters'][i[0]] = chapter
                data['ranobe']['future-chapters'][i[0]] = all
                self.ranobe_percent = int((i[0] + 1) / length * 100)
            except Exception as e:
                data['ranobe']['log'] = f'Error ==>\n{e}' 
                system(f'notify-send "Error for get data about <ranobe>\n{e}"')
        data['ranobe']['log'] = ''
        data['notify']['notify'] = checkVoice(data, msg)
        sleep(1.2)
        self.ranobe_percent = 0
        self.setGlobalSettings(data, '', '', '', False, True)


if __name__ == "__main__":
    app = QtWidgets.QApplication([])
    application = myWindow()
    exit(app.exec())
